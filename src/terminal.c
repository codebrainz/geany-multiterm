/* terminal.c generated by valac 0.11.6.38-0ec3, the Vala compiler
 * generated from terminal.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "multiterm.h"
#include <vte/vte.h>
#include <gtk/gtk.h>
#include <string.h>
#include <gdk/gdk.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))


static gpointer multi_term_terminal_parent_class = NULL;

enum  {
	MULTI_TERM_TERMINAL_DUMMY_PROPERTY,
	MULTI_TERM_TERMINAL_TAB_LABEL_TEXT,
	MULTI_TERM_TERMINAL_BACKGROUND_COLOR,
	MULTI_TERM_TERMINAL_FOREGROUND_COLOR
};
static void multi_term_terminal_on_window_title_changed (MultiTermTerminal* self);
static void multi_term_terminal_on_vte_realize (MultiTermTerminal* self);
static void _multi_term_terminal_on_window_title_changed_vte_terminal_window_title_changed (VteTerminal* _sender, gpointer self);
static void _multi_term_terminal_on_vte_realize_gtk_widget_realize (GtkWidget* _sender, gpointer self);
static void multi_term_terminal_finalize (GObject* obj);
static void _vala_multi_term_terminal_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_multi_term_terminal_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


static void multi_term_terminal_on_window_title_changed (MultiTermTerminal* self) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = vte_terminal_get_window_title (self->terminal);
	multi_term_terminal_set_tab_label_text (self, _tmp0_);
}


static void multi_term_terminal_on_vte_realize (MultiTermTerminal* self) {
	g_return_if_fail (self != NULL);
	multi_term_terminal_set_background_color (self, "white");
	multi_term_terminal_set_foreground_color (self, "black");
}


static void _multi_term_terminal_on_window_title_changed_vte_terminal_window_title_changed (VteTerminal* _sender, gpointer self) {
	multi_term_terminal_on_window_title_changed (self);
}


static void _multi_term_terminal_on_vte_realize_gtk_widget_realize (GtkWidget* _sender, gpointer self) {
	multi_term_terminal_on_vte_realize (self);
}


MultiTermTerminal* multi_term_terminal_construct (GType object_type) {
	MultiTermTerminal * self = NULL;
	GtkVScrollbar* vsb = NULL;
	GtkHBox* hbox = NULL;
	VteTerminal* _tmp0_ = NULL;
	GtkAdjustment* _tmp1_ = NULL;
	GtkVScrollbar* _tmp2_ = NULL;
	GtkHBox* _tmp3_ = NULL;
	self = (MultiTermTerminal*) g_object_new (object_type, NULL);
	_tmp0_ = (VteTerminal*) vte_terminal_new ();
	_g_object_unref0 (self->terminal);
	self->terminal = g_object_ref_sink (_tmp0_);
	gtk_widget_set_size_request ((GtkWidget*) self->terminal, 100, 100);
	gtk_widget_show_all ((GtkWidget*) self->terminal);
	_tmp1_ = vte_terminal_get_adjustment (self->terminal);
	_tmp2_ = (GtkVScrollbar*) gtk_vscrollbar_new (_tmp1_);
	_g_object_unref0 (vsb);
	vsb = g_object_ref_sink (_tmp2_);
	_tmp3_ = (GtkHBox*) gtk_hbox_new (FALSE, 0);
	_g_object_unref0 (hbox);
	hbox = g_object_ref_sink (_tmp3_);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) self->terminal, TRUE, TRUE, (guint) 0);
	gtk_box_pack_start ((GtkBox*) hbox, (GtkWidget*) vsb, FALSE, FALSE, (guint) 0);
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) hbox);
	g_signal_connect_object (self->terminal, "window-title-changed", (GCallback) _multi_term_terminal_on_window_title_changed_vte_terminal_window_title_changed, self, 0);
	vte_terminal_set_font_from_string_full (self->terminal, "Monospace 9", VTE_ANTI_ALIAS_FORCE_ENABLE);
	g_signal_connect_object ((GtkWidget*) self->terminal, "realize", (GCallback) _multi_term_terminal_on_vte_realize_gtk_widget_realize, self, 0);
	vte_terminal_fork_command (self->terminal, NULL, NULL, NULL, NULL, TRUE, TRUE, TRUE);
	_g_object_unref0 (hbox);
	_g_object_unref0 (vsb);
	return self;
}


MultiTermTerminal* multi_term_terminal_new (void) {
	return multi_term_terminal_construct (MULTI_TERM_TYPE_TERMINAL);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


const gchar* multi_term_terminal_get_tab_label_text (MultiTermTerminal* self) {
	const gchar* result;
	gconstpointer _tmp0_ = NULL;
	MultiTermTabLabel* _tmp1_;
	MultiTermTabLabel* label;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_object_get_data ((GObject*) self, "label");
	_tmp1_ = _g_object_ref0 ((MultiTermTabLabel*) _tmp0_);
	label = _tmp1_;
	_tmp2_ = multi_term_tab_label_get_text (label);
	result = _tmp2_;
	_g_object_unref0 (label);
	return result;
}


void multi_term_terminal_set_tab_label_text (MultiTermTerminal* self, const gchar* value) {
	gconstpointer _tmp0_ = NULL;
	MultiTermTabLabel* _tmp1_;
	MultiTermTabLabel* label;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_object_get_data ((GObject*) self, "label");
	_tmp1_ = _g_object_ref0 ((MultiTermTabLabel*) _tmp0_);
	label = _tmp1_;
	multi_term_tab_label_set_text (label, value);
	_g_object_unref0 (label);
	g_object_notify ((GObject *) self, "tab-label-text");
}


void multi_term_terminal_set_background_color (MultiTermTerminal* self, const gchar* value) {
	GdkColor color = {0};
	GdkColormap* _tmp0_ = NULL;
	GdkColor _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	memset (&color, 0, sizeof (GdkColor));
	_tmp0_ = gdk_colormap_get_system ();
	gdk_colormap_alloc_color (_tmp0_, &color, TRUE, TRUE);
	gdk_color_parse (value, &_tmp1_);
	color = _tmp1_;
	vte_terminal_set_color_background (self->terminal, &color);
	g_object_notify ((GObject *) self, "background-color");
}


void multi_term_terminal_set_foreground_color (MultiTermTerminal* self, const gchar* value) {
	GdkColor color = {0};
	GdkColormap* _tmp0_ = NULL;
	GdkColor _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	memset (&color, 0, sizeof (GdkColor));
	_tmp0_ = gdk_colormap_get_system ();
	gdk_colormap_alloc_color (_tmp0_, &color, TRUE, TRUE);
	gdk_color_parse (value, &_tmp1_);
	color = _tmp1_;
	vte_terminal_set_color_foreground (self->terminal, &color);
	g_object_notify ((GObject *) self, "foreground-color");
}


static void multi_term_terminal_class_init (MultiTermTerminalClass * klass) {
	multi_term_terminal_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_multi_term_terminal_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_multi_term_terminal_set_property;
	G_OBJECT_CLASS (klass)->finalize = multi_term_terminal_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_TERM_TERMINAL_TAB_LABEL_TEXT, g_param_spec_string ("tab-label-text", "tab-label-text", "tab-label-text", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_TERM_TERMINAL_BACKGROUND_COLOR, g_param_spec_string ("background-color", "background-color", "background-color", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_TERM_TERMINAL_FOREGROUND_COLOR, g_param_spec_string ("foreground-color", "foreground-color", "foreground-color", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE));
}


static void multi_term_terminal_instance_init (MultiTermTerminal * self) {
}


static void multi_term_terminal_finalize (GObject* obj) {
	MultiTermTerminal * self;
	self = MULTI_TERM_TERMINAL (obj);
	_g_object_unref0 (self->terminal);
	G_OBJECT_CLASS (multi_term_terminal_parent_class)->finalize (obj);
}


GType multi_term_terminal_get_type (void) {
	static volatile gsize multi_term_terminal_type_id__volatile = 0;
	if (g_once_init_enter (&multi_term_terminal_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MultiTermTerminalClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multi_term_terminal_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiTermTerminal), 0, (GInstanceInitFunc) multi_term_terminal_instance_init, NULL };
		GType multi_term_terminal_type_id;
		multi_term_terminal_type_id = g_type_register_static (GTK_TYPE_FRAME, "MultiTermTerminal", &g_define_type_info, 0);
		g_once_init_leave (&multi_term_terminal_type_id__volatile, multi_term_terminal_type_id);
	}
	return multi_term_terminal_type_id__volatile;
}


static void _vala_multi_term_terminal_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	MultiTermTerminal * self;
	self = MULTI_TERM_TERMINAL (object);
	switch (property_id) {
		case MULTI_TERM_TERMINAL_TAB_LABEL_TEXT:
		g_value_set_string (value, multi_term_terminal_get_tab_label_text (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_multi_term_terminal_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	MultiTermTerminal * self;
	self = MULTI_TERM_TERMINAL (object);
	switch (property_id) {
		case MULTI_TERM_TERMINAL_TAB_LABEL_TEXT:
		multi_term_terminal_set_tab_label_text (self, g_value_get_string (value));
		break;
		case MULTI_TERM_TERMINAL_BACKGROUND_COLOR:
		multi_term_terminal_set_background_color (self, g_value_get_string (value));
		break;
		case MULTI_TERM_TERMINAL_FOREGROUND_COLOR:
		multi_term_terminal_set_foreground_color (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



