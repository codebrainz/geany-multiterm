/* python.c generated by valac 0.11.6.38-0ec3, the Vala compiler
 * generated from python.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include "multiterm.h"
#include <stdlib.h>
#include <string.h>
#include <vte/vte.h>

#define _g_free0(var) (var = (g_free (var), NULL))


static gpointer multi_term_python_terminal_parent_class = NULL;

enum  {
	MULTI_TERM_PYTHON_TERMINAL_DUMMY_PROPERTY
};
static void multi_term_python_terminal_real_init_shell (MultiTermTerminal* base);


static void multi_term_python_terminal_real_init_shell (MultiTermTerminal* base) {
	MultiTermPythonTerminal * self;
	gchar* _tmp0_ = NULL;
	gchar* py;
	self = (MultiTermPythonTerminal*) base;
	_tmp0_ = g_find_program_in_path ("bpython");
	py = _tmp0_;
	if (py == NULL) {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_find_program_in_path ("python");
		_g_free0 (py);
		py = _tmp1_;
		if (py == NULL) {
			vte_terminal_fork_command (((MultiTermTerminal*) self)->terminal, NULL, NULL, NULL, NULL, TRUE, TRUE, TRUE);
			multi_term_iterminal_run_command ((MultiTermITerminal*) self, "echo \"No Python interpreter was located.\"");
		} else {
			vte_terminal_fork_command (((MultiTermTerminal*) self)->terminal, py, NULL, NULL, NULL, TRUE, TRUE, TRUE);
		}
	} else {
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		_tmp2_ = g_strdup_printf ("%s", py);
		_tmp3_ = _tmp2_;
		vte_terminal_fork_command (((MultiTermTerminal*) self)->terminal, _tmp3_, NULL, NULL, NULL, TRUE, TRUE, TRUE);
		_g_free0 (_tmp3_);
	}
	_g_free0 (py);
}


MultiTermPythonTerminal* multi_term_python_terminal_construct (GType object_type) {
	MultiTermPythonTerminal * self = NULL;
	self = (MultiTermPythonTerminal*) multi_term_terminal_construct (object_type);
	return self;
}


MultiTermPythonTerminal* multi_term_python_terminal_new (void) {
	return multi_term_python_terminal_construct (MULTI_TERM_TYPE_PYTHON_TERMINAL);
}


static void multi_term_python_terminal_class_init (MultiTermPythonTerminalClass * klass) {
	multi_term_python_terminal_parent_class = g_type_class_peek_parent (klass);
	MULTI_TERM_TERMINAL_CLASS (klass)->init_shell = multi_term_python_terminal_real_init_shell;
}


static void multi_term_python_terminal_instance_init (MultiTermPythonTerminal * self) {
}


GType multi_term_python_terminal_get_type (void) {
	static volatile gsize multi_term_python_terminal_type_id__volatile = 0;
	if (g_once_init_enter (&multi_term_python_terminal_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MultiTermPythonTerminalClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multi_term_python_terminal_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiTermPythonTerminal), 0, (GInstanceInitFunc) multi_term_python_terminal_instance_init, NULL };
		GType multi_term_python_terminal_type_id;
		multi_term_python_terminal_type_id = g_type_register_static (MULTI_TERM_TYPE_TERMINAL, "MultiTermPythonTerminal", &g_define_type_info, 0);
		g_once_init_leave (&multi_term_python_terminal_type_id__volatile, multi_term_python_terminal_type_id);
	}
	return multi_term_python_terminal_type_id__volatile;
}



